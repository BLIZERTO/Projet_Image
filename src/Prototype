import fr.unistra.pelican.ByteImage;
import fr.unistra.pelican.algorithms.io.ImageLoader;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.lang.Math;
import java.util.Set;
import java.util.TreeMap;
import java.util.function.DoubleToIntFunction;

import fr.unistra.pelican.Image;
import fr.unistra.pelican.algorithms.visualisation.Viewer2D;

import javax.imageio.ImageIO;

import static java.lang.Math.*;


public class PartieI {

    public static void main(String[] args) throws IOException {
        Image image = ImageLoader.exec("C:\\Users\\elodi\\OneDrive\\Documents\\Dut informatique 2\\Image\\Image\\motos\\motos\\000.jpg");
        Image image2 = ImageLoader.exec("C:\\Users\\elodi\\OneDrive\\Documents\\Dut informatique 2\\Image\\Image\\motos\\motos\\001.jpg");

        CanalHisto nvlImage = new CanalHisto(image);
        CanalHisto nvlImageR= new CanalHisto(image2);


        double[] nvBleuImage = discretisation(nvlImage.getCBleu());
        double[] nvVertImage = discretisation(nvlImage.getCVert());
        double[] nvRougeImage = discretisation(nvlImage.getCRouge());
        double[] nvBleuImageR = discretisation(nvlImage.getCBleu());
        double[] nvVertImageR = discretisation(nvlImage.getCVert());
        double[] nvRougeImageR = discretisation(nvlImage.getCRouge());
        nvBleuImage=normalisation(nvBleuImage);
        nvRougeImage=normalisation(nvRougeImage);
        nvVertImage=normalisation(nvVertImage);
        nvBleuImageR=normalisation(nvBleuImageR);
        nvRougeImageR=normalisation(nvRougeImageR);
        nvVertImageR=normalisation(nvVertImageR);
        HistogramTools.plotHistogram(nvBleuImage, "bleu");
        //Recherche("C:\\Users\\elodi\\OneDrive\\Documents\\Dut informatique 2\\Image\\Image\\Test");
       // nvBleuImage=normalisation(nvBleuImage);
        Image median = median(image);
        Image median2 = median(image2);
        //HistogramTools.plotHistogram(nvBleuImage, "bleu");

       ImageDistance(nvlImage,nvlImageR);
    }

    public static Image median(Image image) {
        /**
         * Cette fonction appelle la fonction medianCouleur ou medianGris en fonction du nombres de canaux dans une image
         */
        ImageCouleur couleur = new ImageCouleur(image);
        if(couleur.getCouleur()==true){
        /*if (image.getBDim() > 2) {*/
            return medianCouleur(image);
        } else {
            return medianGris(image);
        }

    }

    public static Image medianCouleur(Image imageDepart) {
        /**
         * Cette fonction applique le filtre median sur l'imageDepart qui est une image en couleur.
         *
         * @param imageDepart l'imageDepart est l'image bruité à réparer
         *
         */
        ByteImage new_image = new ByteImage(imageDepart.getXDim(), imageDepart.getYDim(), 1, 1, 3);

        for (int x = 1; x < imageDepart.getXDim() - 1; x++) {
            for (int y = 1; y < imageDepart.getYDim() - 1; y++) {


                int[] TabCanal0 = { //
                        imageDepart.getPixelXYBByte(x, y, 0),
                        imageDepart.getPixelXYBByte(x + 1, y + 1, 0),
                        imageDepart.getPixelXYBByte(x - 1, y - 1, 0),
                        imageDepart.getPixelXYBByte(x - 1, y, 0),
                        imageDepart.getPixelXYBByte(x, y - 1, 0),
                        imageDepart.getPixelXYBByte(x - 1, y + 1, 0),
                        imageDepart.getPixelXYBByte(x + 1, y - 1, 0),
                        imageDepart.getPixelXYBByte(x, y + 1, 0),
                        imageDepart.getPixelXYBByte(x + 1, y, 0)};


                int[] TabCanal1 = { //
                        imageDepart.getPixelXYBByte(x, y, 1),
                        imageDepart.getPixelXYBByte(x + 1, y + 1, 1),
                        imageDepart.getPixelXYBByte(x - 1, y - 1, 1),
                        imageDepart.getPixelXYBByte(x - 1, y, 1),
                        imageDepart.getPixelXYBByte(x, y - 1, 1),
                        imageDepart.getPixelXYBByte(x - 1, y + 1, 1),
                        imageDepart.getPixelXYBByte(x + 1, y - 1, 1),
                        imageDepart.getPixelXYBByte(x, y + 1, 1),
                        imageDepart.getPixelXYBByte(x + 1, y, 1)
                };
                int[] TabCanal2 = { //
                        imageDepart.getPixelXYBByte(x, y, 2),
                        imageDepart.getPixelXYBByte(x + 1, y + 1, 2),
                        imageDepart.getPixelXYBByte(x - 1, y - 1, 2),
                        imageDepart.getPixelXYBByte(x - 1, y, 2),
                        imageDepart.getPixelXYBByte(x, y - 1, 2),
                        imageDepart.getPixelXYBByte(x - 1, y + 1, 2),
                        imageDepart.getPixelXYBByte(x + 1, y - 1, 2),
                        imageDepart.getPixelXYBByte(x, y + 1, 2),
                        imageDepart.getPixelXYBByte(x + 1, y, 2)
                };

                Arrays.sort(TabCanal0);
                Arrays.sort(TabCanal1);
                Arrays.sort(TabCanal2);
                int mediane1 = TabCanal0[TabCanal0.length / 2];
                int mediane2 = TabCanal1[TabCanal1.length / 2];
                int mediane3 = TabCanal2[TabCanal2.length / 2];
                new_image.setPixelXYBByte(x, y, 0, mediane1);
                new_image.setPixelXYBByte(x, y, 1, mediane2);
                new_image.setPixelXYBByte(x, y, 2, mediane3);
            }
        }


        return new_image;
    }

    public static Image medianGris(Image imageDepart) {
        /**
         * Cette fonction applique le filtre median sur l'imageDepart qui est une image de couleur grise.
         *
         * @param imageDepart l'imageDepart bruitée à traiter
         *
         */
        ByteImage new_image = new ByteImage(imageDepart.getXDim(), imageDepart.getYDim(), 1, 1, 1);

        for (int x = 1; x < imageDepart.getXDim() - 1; x++) {
            for (int y = 1; y < imageDepart.getYDim() - 1; y++) {
                int[] array1 = {
                        imageDepart.getPixelXYBByte(x, y, 0),
                        imageDepart.getPixelXYBByte(x + 1, y + 1, 0),
                        imageDepart.getPixelXYBByte(x - 1, y - 1, 0),
                        imageDepart.getPixelXYBByte(x - 1, y, 0),
                        imageDepart.getPixelXYBByte(x, y - 1, 0),
                        imageDepart.getPixelXYBByte(x - 1, y + 1, 0),
                        imageDepart.getPixelXYBByte(x + 1, y - 1, 0),
                        imageDepart.getPixelXYBByte(x, y + 1, 0),
                        imageDepart.getPixelXYBByte(x + 1, y, 0)};

                Arrays.sort(array1);

                int mediane1 = array1[array1.length / 2];

                new_image.setPixelXYBByte(x, y, 0, mediane1);

            }
        }

        return new_image;
    }


    private static File[] Recherche(String fichier) throws IOException {


        File folder = new File(fichier);
        File[] listeImage = folder.listFiles();
        for (int i = 0; i < listeImage.length; i++) {

            Image image = median(ImageLoader.exec(String.valueOf(listeImage[i])));
            System.out.println(listeImage[i].getName());
            image.setColor(true);
            Viewer2D.exec(image);
            /**/
        }
        return listeImage;
    }

    private static double[] discretisation(double[] histogram) {

        /*int nvlValeur = histogram.length / nbDiv;*/ //division de la taille de l'histogramme par un nombre donné en paramètres.
        double[] nouvelHisto = new double[histogram.length / 2];

        for (int i = 0; i < nouvelHisto.length - 1; i = i + 2) {

            nouvelHisto[i] = histogram[i] + histogram[i + 1];  //
        }

        return nouvelHisto;
    }

    private static double[] normalisation(double[] histogram) {
        double pourcentage = 0;
        double[] histo = new double[histogram.length];
        int totalPixels = 0;


        for (int i = 0; i < histogram.length; i++) {
            totalPixels += histogram[i];
            histo[i] = (histogram[i] * 100) / totalPixels;
            pourcentage += histo[i];
        }
        System.out.println(totalPixels);

        return histo;
    }


    public static double[] getHisto(Image image, int canal) {
        double histogramme[] = new double[256];
        for (int i = 0; i < histogramme.length; i++) {
            histogramme[i] = 0;
        }
        for (int x = 0; x < image.getXDim(); x++) {
            for (int y = 0; y < image.getYDim(); y++) {
                histogramme[image.getPixelXYBByte(x, y, canal)] += 1;
            }
        }

        return histogramme;
    }


    public static double ImageDistance(CanalHisto reference, CanalHisto imageComp) throws IOException {
        ImageCouleur couleur1 = new ImageCouleur(reference.getImage());
        ImageCouleur couleur2= new ImageCouleur(imageComp.getImage());
        TreeMap<Double,Image> liste = new TreeMap<>();
        double distance1 = 0;
        double distance2 = 0;
        double distance3 = 0;
        Viewer2D.exec(reference.getImage());

        Viewer2D.exec(imageComp.getImage());

        int expo = 2;

        //Test image en couleur
        if(couleur1.getCouleur()==true && couleur2.getCouleur()==true) { //reference.getImg().getBDim() > 2 && imageComp.getImg().getBDim() > 2

            for (int c = 0; c < reference.getCBleu().length; c++) {
                double calcul = reference.getCBleu()[c] - imageComp.getCBleu()[c];
                distance1 += Math.pow(calcul, expo);
            }
            for (int d = 0; d < reference.getCVert().length; d++) {
                double calcul = reference.getCVert()[d] - imageComp.getCVert()[d];
                distance2 += Math.pow(calcul, expo);
            }

        }

            for (int g = 0; g < reference.getCRouge().length; g++) {
                double calcul = reference.getCRouge()[g] - imageComp.getCRouge()[g];
                distance3 += Math.pow(calcul, expo);
            }

        double distanceEuclidienne1= Math.sqrt(distance1);
        double distanceEuclidienne2 = Math.sqrt(distance2);
        double distanceEuclidienne3= Math.sqrt(distance3);
        double distanceFinale=distanceEuclidienne1+distanceEuclidienne2+distanceEuclidienne3;
        liste.put(distanceFinale,reference.getImage());
        Set set=liste.keySet();
        System.out.println(set);
    return distanceFinale;
    }

   /*public static double ImageSimilaire(CanalHisto reference, CanalHisto imageComp) throws IOException
    {

    }*/
}

